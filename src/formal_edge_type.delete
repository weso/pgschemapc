use std::{collections::HashMap, fmt::Display};

use either::Either;

use crate::{
    edge::Edge, evidence::Evidence, formal_graph_type::FormalGraphType,
    parser::pgs_actions::LabelPropertySpec, pgs_error::PgsError, type_name::TypeName,
};

#[derive(Debug, Clone)]
pub struct FormalEdgeType {
    map: HashMap<TypeName, EdgeType>,
    blank_counter: usize,
}

#[derive(Debug, Clone)]
pub struct EdgeType {
    pub source: LabelPropertySpec,
    pub edge: LabelPropertySpec,
    pub target: LabelPropertySpec,
}

impl FormalEdgeType {
    pub fn new() -> Self {
        FormalEdgeType {
            map: HashMap::new(),
            blank_counter: 0,
        }
    }

    pub fn conforms_edge(
        &self,
        type_name: &TypeName,
        edge: &Edge,
    ) -> Either<Vec<PgsError>, Vec<Evidence>> {
        // Implementation for checking if the edge conforms to the type
        // This is a placeholder; actual implementation would depend on the edge structure
        Either::Right(vec![]) // Placeholder for evidence
    }
}

impl Display for FormalEdgeType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EdgeType(({})-[{}]->({})",
            self.source, self.edge, self.target
        )
    }
}
