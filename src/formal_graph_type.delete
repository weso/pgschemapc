use std::{collections::HashMap, fmt::Display, path::Path};

use either::Either;

// use crate::parser::pgs_builder::PgsBuilder;
use crate::{
    edge::Edge, evidence::Evidence, label_property_spec::LabelPropertySpec, node::Node,
    pgs_error::PgsError, type_name::TypeName,
};

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FormalGraphType {
    map: HashMap<TypeName, LabelPropertySpec>,
    blank_counter: usize,
}

impl FormalGraphType {
    pub fn new() -> Self {
        FormalGraphType {
            map: HashMap::new(),
            blank_counter: 0,
        }
    }

    /*  TODO: It gives an error because PgsBuilder is not in scope
       pub fn from_path<P: AsRef<Path>>(path: P) -> Result<Self, PgsError> {
        let content =
            std::fs::read_to_string(&path).map_err(|e| PgsError::PGSchemaFileReadError {
                path: path.as_ref().to_str().unwrap().to_string(),
                error: e.to_string(),
            })?;
        PgsBuilder::new().parse_pgs(content.as_str())
    } */

    pub fn with_type_name(
        mut self,
        type_name: &str,
        label_property_spec: LabelPropertySpec,
    ) -> Self {
        self.map.insert(type_name.to_string(), label_property_spec);
        self
    }

    pub fn add(&mut self, type_name: &str, label_property_spec: LabelPropertySpec) {
        self.map.insert(type_name.to_string(), label_property_spec);
    }

    pub fn add_blank(&mut self, label_property_spec: LabelPropertySpec) {
        let type_name = format!("{}", self.blank_counter);
        self.blank_counter += 1;
        self.add(&type_name, label_property_spec);
    }

    pub fn get(&self, type_name: &str) -> Option<&LabelPropertySpec> {
        self.map.get(type_name)
    }

    pub fn conforms_node(
        &self,
        type_name: &TypeName,
        node: &Node,
    ) -> Either<Vec<PgsError>, Vec<Evidence>> {
        if let Some(label_property_spec) = self.get(type_name) {
            match label_property_spec.semantics(self) {
                Ok(base_type) => base_type.conforms(node.labels(), node.content()),
                Err(e) => return Either::Left(vec![e]),
            }
        } else {
            Either::Left(vec![PgsError::MissingType(type_name.clone())])
        }
    }

    pub fn conforms_edge(
        &self,
        type_name: &TypeName,
        edge: &Edge,
    ) -> Either<Vec<PgsError>, Vec<Evidence>> {
        if let Some(label_property_spec) = self.get(type_name) {
            match label_property_spec.semantics(self) {
                Ok(base_type) => base_type.conforms(edge.labels(), edge.content()),
                Err(e) => return Either::Left(vec![e]),
            }
        } else {
            Either::Left(vec![PgsError::MissingType(type_name.clone())])
        }
    }
}

impl Display for FormalGraphType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for (key, value) in self.map.iter() {
            writeln!(f, "{}: {}", key, value)?;
        }
        Ok(())
    }
}
